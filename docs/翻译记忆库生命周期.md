# 翻译记忆库生命周期详解

## ❓ 关键问题

**Q: 学习到的新短语会参与到后续的预处理中吗？**

**A: 会的！但有一个重要的前提条件。**

## 🔍 完整生命周期追踪

### 场景1: 单次翻译会话（同一个PO文件）

```python
# 第1批翻译（1-10条）
POTranslator.__init__()
    └─> TranslationMemory.__init__()
        └─> self.memory.update(BUILTIN_PHRASES)      # 加载内置57条
        └─> self._load_from_file()                   # 加载translation_memory.json（首次为空）
        └─> 内存中共57条

translate_batch(texts[0:10])
    └─> preprocess_batch()
        └─> 检查57条内置短语
        └─> 命中3条，7条需要AI翻译
    └─> _translate_with_ai(7条)
        └─> AI翻译完成
        └─> 自动学习：if is_simple_phrase(): tm.add()
        └─> 内存中新增5条学习记录 → 总共62条（但未保存到文件）

# 第2批翻译（11-20条）
translate_batch(texts[10:20])
    └─> preprocess_batch()
        └─> 检查62条（57内置 + 5新学习）  ✅ 新学习的会被使用！
        └─> 命中6条（包括刚学习的2条）
    └─> _translate_with_ai(4条)
        └─> 继续学习新短语...

# 第3批、第4批...
# 都会使用已学习的短语

# 翻译结束
translate_po_file() 结束
    └─> tm.save_to_file()                           # 保存到translation_memory.json
    └─> 磁盘文件现在包含所有学习的短语
```

**✅ 结论1: 同一次翻译会话中，新学习的短语**立即**可用于后续批次！**

---

### 场景2: 跨翻译会话（不同时间运行）

#### 第一次运行（今天）

```python
# run.py 启动 → 选择翻译
python run.py

# 创建新的POTranslator实例
translator = POTranslator(api_key)
    └─> tm = TranslationMemory()
        └─> 加载内置57条
        └─> 加载translation_memory.json（不存在，跳过）
        └─> 内存：57条

# 翻译100条
# 学习了20条新短语
# 结束时保存到translation_memory.json
```

**文件系统状态：**
```json
// translation_memory.json (新创建)
{
  "learned": {
    "Custom Term 1": "自定义术语1",
    "Custom Term 2": "自定义术语2",
    ...
    // 共20条
  },
  "last_updated": "2025-10-06 10:00:00"
}
```

#### 第二次运行（明天）

```python
# 重新启动
python run.py

# 创建新的POTranslator实例
translator = POTranslator(api_key)
    └─> tm = TranslationMemory()
        └─> 加载内置57条
        └─> 加载translation_memory.json（存在！）✅
            └─> self.memory.update(learned)         # 合并20条学习记录
        └─> 内存：77条（57内置 + 20学习）

# 翻译新的100条
preprocess_batch()
    └─> 检查77条（包括昨天学习的20条）✅
    └─> 命中率显著提升！
```

**✅ 结论2: 跨会话时，上次学习的短语会被加载并使用！**

---

### 场景3: 多次翻译累积

```
第1次翻译: 57内置 + 学习20条 → 保存到文件
           ↓
第2次翻译: 加载57+20=77条 + 学习15条新的 → 保存92条到文件  
           ↓
第3次翻译: 加载57+35=92条 + 学习10条新的 → 保存102条到文件
           ↓
...持续累积
```

## 🔑 关键代码证明

### 1. 初始化时会加载文件

```python
# src/translation_memory.py: 108行
def __init__(self, memory_file: str = "translation_memory.json"):
    # ...
    self.memory.update(self.BUILTIN_PHRASES)  # 先加载内置
    self._load_from_file()                    # 再加载文件 ✅

# 110-124行
def _load_from_file(self):
    if os.path.exists(self.memory_file):      # 检查文件存在
        data = json.load(f)
        learned = data.get("learned", {})
        self.memory.update(learned)            # 合并到内存 ✅
```

### 2. 查询时检查整个内存

```python
# src/translation_memory.py: 146-169行
def get(self, text: str) -> str:
    if text in self.memory:                    # 检查整个内存字典 ✅
        return self.memory[text]               # 包括内置 + 文件加载的
```

### 3. 预处理时使用get()方法

```python
# src/translation_memory.py: 255-275行
def preprocess_batch(self, texts: List[str]):
    for idx, text in enumerate(texts):
        translation = self.get(text)           # 调用get() ✅
        if translation:                        # 会命中内置或学习的
            cached_translations[idx] = translation
```

### 4. 翻译后即时学习

```python
# src/po_translator.py: 194-198行
ai_translations = self._translate_with_ai(need_ai_translation)
for i in range(len(texts)):
    if i in cached:
        result.append(cached[i])
    else:
        result.append(ai_translations[ai_idx])
        if self.tm.is_simple_phrase(texts[i]):
            self.tm.add(texts[i], ai_translations[ai_idx])  # 立即添加到内存 ✅
```

## ✅ 最终确认

### 问题1: 新学习的短语会参与后续预处理吗？
**答案: 会！**
- 同一会话：立即在内存中可用
- 跨会话：从文件加载后可用

### 问题2: translation_memory.json会被读取吗？
**答案: 会！**
- 每次创建`TranslationMemory()`实例时自动加载
- 代码位置: `__init__()` → `_load_from_file()`

### 问题3: 内存和文件如何同步？
**答案:**
```
内存(self.memory) ← 加载 ← 文件(translation_memory.json)
     ↓
   翻译+学习
     ↓
内存(self.memory) → 保存 → 文件(translation_memory.json)
```

## 📝 验证方法

### 测试1: 验证学习功能

```bash
# 第一次翻译
python run.py
# 观察输出：
# [TM] 翻译记忆库已启用
# [TM] 加载翻译记忆库: 0 条学习记录  ← 首次为空
# ...翻译过程...
# [TM] 保存翻译记忆库: 15 条学习记录  ← 学习了15条

# 检查文件
cat translation_memory.json
```

### 测试2: 验证加载功能

```bash
# 第二次翻译（不删除translation_memory.json）
python run.py
# 观察输出：
# [TM] 翻译记忆库已启用
# [TM] 加载翻译记忆库: 15 条学习记录  ← 成功加载！✅
# [TM] 缓存命中 8/10, 需AI翻译 2     ← 使用了学习的短语！✅
```

### 测试3: 验证累积效果

```bash
# 查看统计
python tools/manage_tm.py --stats

# 输出:
# 记忆库条目: 72 (内置: 57, 学习: 15)  ← 总数 = 内置 + 学习
# 查询命中: 145 / 200 (72.5%)
```

## ⚠️ 唯一的限制

**每次会话只创建一个`TranslationMemory`实例**

```python
# POTranslator初始化时创建TM
translator = POTranslator(api_key)
    └─> self.tm = TranslationMemory()  # 只创建一次

# 翻译一个PO文件时
translator.translate_po_file("file.po")
    # 使用同一个tm实例
    # 学习的短语保存在内存中
    # 结束时保存到文件
```

**如果你在代码中多次创建`POTranslator`：**
```python
# 不推荐（但也能工作）
translator1 = POTranslator(api_key)  # 创建TM实例1，加载文件
translator1.translate_po_file("a.po")  # 学习短语，保存到文件

translator2 = POTranslator(api_key)  # 创建TM实例2，重新加载文件（包含translator1学习的）✅
translator2.translate_po_file("b.po")  # 能使用translator1学习的短语
```

## 📊 数据流图

```
启动程序
    ↓
POTranslator.__init__()
    ↓
TranslationMemory.__init__()
    ↓
加载: BUILTIN_PHRASES (代码) + translation_memory.json (文件)
    ↓
self.memory (内存字典)
    ├─> preprocess_batch() 查询
    ├─> get() 返回翻译
    └─> add() 学习新短语 (即时生效)
    ↓
translate_po_file() 结束
    ↓
save_to_file()
    ↓
translation_memory.json (持久化)
    ↓
下次运行时被加载 ✅
```

## 🎯 总结

✅ **是的，新学习的短语会参与后续预处理！**

- **同会话**: 立即生效（内存中）
- **跨会话**: 从文件加载后生效
- **机制**: 初始化时自动加载 → 使用时检查 → 学习后立即可用 → 结束时保存

这就是为什么翻译记忆库能够**持续优化**，越用越好的原因！

---

**验证命令:**
```bash
# 查看学习记录
python tools/manage_tm.py --list learned

# 查看完整统计
python tools/manage_tm.py --stats
```

